#include<iostream>
#include<string>
using namespace std;
/*
	템플릿은 개방 폐쇄 원칙을 지키면서 여러가지 용도로 널리 쓸 수 있는 함수를 만드는 방법이다.

	템플릿을 이용하면 중복되는 코드를 줄이고 함수의 알고리즘이 변경될 때 대응하기 편하다.

	템플릿을 사용하면 매개변수의 데이터 형식을 함수를 작성하는 시점이 아닌
	사용하는 시점에 정할 수 있다.

	함수 템플릿은 한 번 정의해 놓으면 다양한 데이터 형식을 처리할 수 있다.
	따라서, 함수 템플릿은 모든 데이터 형식에 대응할 수 있는 알고리즘으로 정의해야한다.

	템플릿의 인스턴스화 : 컴파일러는 함수 템플릿을 호출하는 구문을 만나면 인자로 전달한 값으로
	템플릿 매개변수의 데이터 형식을 추론하고, 이 형식으로 완성된 함수를 오브젝트 코드로 만든다.

	함수 템플릿은 여러 가지 데이터 형식에 대응해야 하므로, 데이터 형식별로 알맞은
	오브젝트 코드가 만들어져야한다. 따라서, 템플릿을 많이 사용하면 사용할 수록
	컴파일 시간이 길어지고 실행 파일의 크기가 커진다.

	컴파일러는 함수 템플릿을 호출하는 구문에서 전달한 값을 바탕으로 데이터 형식을 추론한다.
	이 추론 과정은 시간이 많이 소요되는 작업이며, 데이터 형식이 모호하면 추론이 불가능해 오류가 발생한다.

	이를 해결하기 위해 <>를 이용해 명시적으로 호출하는 방법이 있다.

		char data7[] = "Hello", data8[] = "World!";
		cout << "문자데이터 배열의 합 : " << data_sum<string>(data7, data8) << endl;
	위와 같이 <>를 이용해 데이터 형식을 직접 지정해줄 수 있다.
*/

template <typename T>
T data_sum(T operand1, T operand2) {
	return operand1 + operand2;
}

int main()
{
	int data1 = 3, data2 = 5;
	double data3 = 4.5, data4 = 8.9;
	string data5 = "Hello", data6 = "World!";

	cout << "정수형 데이터 합 : " << data_sum(data1, data2) << endl;
	cout << "실수형 데이터 합 : " << data_sum(data3, data4) << endl;
	cout << "문자여 ㄹ데이터 합 : " << data_sum(data5, data6) << endl;
	return 0;
}